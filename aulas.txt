-- 25/03/2022 --------------------
  paradigma orientação orientada a objetos
  sintaxe (linguagem java)
  convenções
 
  composição: do que um objeto é feito
  herança: quais são as superclasses e subclasses 
  encapsulamento: não precisar que outras classes saibam o funcionamento de uma função
  polimorfismo: basicamente no meio do programa poder escolher qual comando usar

  tipos permitidos int, double, bool, char
  estrutura de dados: arrays, list, map, sintaxe

   class gato{
     string nome
     string raça
     string idade
   }

  camelcase em java
  CadastroGato -> classe    cadastroGato -> variável
  NomeDeClasse

  nomes constantes tem TODAS as letras maiúsculas

  system.out.printIn("O numero" + i + "eh par");

  usar @Overide / @Override
----------------------------------
.
.
.
-- 04/03/2022 --------------------
  em Java os atributos são private -> apenas a mesma classe consegue acessar e modificar o valor desse atributo
  exemplo: private String nome;
  
  private, public, protect -> modificadores de acesso
  o método precisa ser public para que outra classe acesse esse atributo ou possa fazer modificações
  
  para ler se usa o método get
  exemplo: public void getNome(){
    return this.nome;
  }
  
  para alterar se usa o método set
  exemplo: public void setNome(String umNome){
    this.nome = umNome;
  }
 
  outros exemplos:
  public void deposita( double valorDeposito){
    this.valor = this.valor + valorDeposito;
  }
  
  public boolean retira( double valorRetirada){
    if(valorRetirada > this.valor){
        system.out("Não foi possível");
        return false;
    }
    this.valor-=valorRetirada;
    return true;
  }
  
  constructor:
  public ContaBancaria(String umNome, string umTipo){
    this.nome = umNome;
    this.valor = 0;
    this.valor = umTipo;
  }
  
  public ContaBancaria(String umNome){
    this(umNome, "normal");
  }
  
  ficaAdica: Reutilizar código para ser mais fácil a atualização
  
  toString
  @Override
  public String toString(){
    String res="";
    res+= "Classe ContaBancaria\n";
    res+= "Nome: " + this.nome+"\n";
    res+= "Valor: " + this.valor+"\n";
    res+= "Tipo: " + this.tipo+"\n";
    return res;
  }
  
  ficaAdica 2: no Eclipse tem como criar os constructors e métodos get e set automático
  
  Lab01.02 ex01 -> VAI CAIR NA PROVAA
  
-- 09/03/2022 --------------------

CREATE DATABASE teste;

CREATE TABLE casa(
  moradores int;
  numero int primary key;
  telefone varchar(10)
);

INSERT casa VALUES(3, 260, "1938090426");

DROP DATABASE teste;
  
-- 18/03/2022 --------------------

array em java

ArrayList <Gato> gatos;
gatos= new ArrayList <Gato> ();
gatos.add (new gatp)("xica");
Gato gato01= new Gato ("miau");
gatos.add (gato01);
gatos.add (gato01);
sout(gatos.get (0));
sout (gatos.get(1));

-- 01/04/2022 --------------------

Prova de LPOO
-> Herança
-> Polimorfismo
-> Classes e objetos
-> Arrays

-- 11/04/2022 --------------------

Chave estrangeira e chave primária 

Campo Matrícula (nome do atributo)

[Matrícula]|
  Registro |

Estabelecer associações ou identificar um registro de maneira única dentro da tabela -> chave primária

Chave estrangeira -> relacionamentos, pego um campo de uma tabela e insiro em outra

Alternate Key (chave alternativa) -> não são chaves primárias, não tem importância na configuração

Composite Key (chave composta) -> junção de dois atributos para criar uma chave

Chave estrangeira só é utiliza quando for 1,n ou n,n

Chave estrangeira nunca será chave primária

Quando temos um relacionamento n:n cria-se uma tabela intermediária
